%% @doc
%% 3D linear algebra functions.
%%
%% @author Alexey Rybakov

% Module name.
-module(jdlib_la3d).

% Export.
-export([v_x/1, v_y/1, v_z/1, v_i/2,
         v_add/2, v_sub/2, v_neg/1, v_mul/2, v_dvs/2, v_inv/1]).

%---------------------------------------------------------------------------------------------------
% Constants and macroses.
%---------------------------------------------------------------------------------------------------

%---------------------------------------------------------------------------------------------------
% Types.
%---------------------------------------------------------------------------------------------------

% Types export.
-export_type([vector/0]).

% Vector.
-type vector() :: [number()].

%---------------------------------------------------------------------------------------------------
% Vector functions.
%---------------------------------------------------------------------------------------------------

-spec v_x(V :: vector()) -> number().
%% @doc
%% X component of vector.
v_x([X, _, _]) ->
    X.

%---------------------------------------------------------------------------------------------------

-spec v_y(V :: vector()) -> number().
%% @doc
%% Y component of vector.
v_y([_, Y, _]) ->
    Y.

%---------------------------------------------------------------------------------------------------

-spec v_z(V :: vector()) -> number().
%% @doc
%% Z component of vector.
v_z([_, _, Z]) ->
    Z.

%---------------------------------------------------------------------------------------------------

-spec v_i(V :: vector(), integer()) -> number().
%% @doc
%% Component of vector.
v_i(V, I) ->
    lists:nth(I, V).

%---------------------------------------------------------------------------------------------------

-spec v_add(V1 :: vector() | number(), V2 :: vector() | number()) -> vector() | number().
%% @doc
%% Vectors addition.
v_add([X1, Y1, Z1], [X2, Y2, Z2]) ->
    [X1 + X2, Y1 + Y2, Z1 + Z2];
v_add([X1, Y1, Z1], V2) ->
    [X1 + V2, Y1 + V2, Z1 + V2];
v_add(V1, [X2, Y2, Z2]) ->
    [V1 + X2, V1 + Y2, V1 + Z2];
v_add(V1, V2) ->
    V1 + V2.

%---------------------------------------------------------------------------------------------------

-spec v_sub(V1 :: vector() | number(), V2 :: vector() | number()) -> vector() | number().
%% @doc
%% Vectors subtraction.
v_sub([X1, Y1, Z1], [X2, Y2, Z2]) ->
    [X1 - X2, Y1 - Y2, Z1 - Z2];
v_sub([X1, Y1, Z1], V2) ->
    [X1 - V2, Y1 - V2, Z1 - V2];
v_sub(V1, [X2, Y2, Z2]) ->
    [V1 - X2, V1 - Y2, V1 - Z2];
v_sub(V1, V2) ->
    V1 - V2.

%---------------------------------------------------------------------------------------------------

-spec v_neg(V :: vector()) -> vector().
%% @doc
%% Negate vector.
v_neg(V) ->
    v_sub(0, V).

%---------------------------------------------------------------------------------------------------

-spec v_mul(V1 :: vector() | number(), V2 :: vector() | number()) -> vector() | number().
%% @doc
%% Vectors componentwise multiplication.
v_mul([X1, Y1, Z1], [X2, Y2, Z2]) ->
    [X1 * X2, Y1 * Y2, Z1 * Z2];
v_mul([X1, Y1, Z1], V2) ->
    [X1 * V2, Y1 * V2, Z1 * V2];
v_mul(V1, [X2, Y2, Z2]) ->
    [V1 * X2, V1 * Y2, V1 * Z2];
v_mul(V1, V2) ->
    V1 * V2.

%---------------------------------------------------------------------------------------------------

-spec v_dvs(V1 :: vector() | number(), V2 :: vector() | number()) -> vector() | number().
%% @doc
%% Vectors componentwise division.
v_dvs([X1, Y1, Z1], [X2, Y2, Z2]) ->
    [X1 / X2, Y1 / Y2, Z1 / Z2];
v_dvs([X1, Y1, Z1], V2) ->
    [X1 / V2, Y1 / V2, Z1 / V2];
v_dvs(V1, [X2, Y2, Z2]) ->
    [V1 / X2, V1 / Y2, V1 / Z2];
v_dvs(V1, V2) ->
    V1 / V2.

%---------------------------------------------------------------------------------------------------

-spec v_inv(V :: vector()) -> vector().
%% @doc
%% Invert vector.
v_inv(V) ->
    v_dvs(1, V).

%---------------------------------------------------------------------------------------------------

